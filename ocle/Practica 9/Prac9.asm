.MODEL SMALL 
	.STACK 100H
	INCLUDE PROCS.INC 
	LOCALS 
	.DATA 
	NEW_LINE DB 10,13,"",0
	MENS DB 10,13,"CALCULANDO EL MCD RECURSIVO",0
	MENS_2 DB 10,13,"EL MCD ES: ",0
	MENS_3 DB 10,13,"EL NUMERO EN BINARIO ES: ",0
	MENS_7 DB 10,13,"JUEGO DE TORRES DE HANOI",0
	MENS_8 DB 10,13,"CONVERSION A BINARIO RECURSIVA",0
	mENS_4 DB 10,13,"DISCO ",0
	mENS_5 DB " : ",0
	mENS_6 DB " -> ",0
	
	.CODE
	MOV AX,@DATA
	MOV DS,AX	;INICIALIZACION DEL SEGMENTO DE DATOS
	
	MOV DX,OFFSET MENS
	CALL PUTS 
	MOV DX,OFFSET MENS_2
	CALL PUTS
	;**************************************************
	XOR AX,AX	;ASEGURAMOS LOS REGISTROS EN CERO 
	XOR BX,BX
	MOV AL,99	;DATO 1
	MOV BL,50	;DATO 2
	CALL MCD 
	CALL PUTCHAR;IMPRIMIMOS EL DATO DE AL
	MOV DX,OFFSET NEW_LINE
	CALL PUTS 
	;**************************************************
	MOV DX,OFFSET MENS_8
	CALL PUTS
	MOV AL,0DAH
	MOV DX,OFFSET MENS_3
	CALL PUTS 
	CALL printBinRec
	MOV DX,OFFSET NEW_LINE
	CALL PUTS 
	;**************************************************
	MOV DX,OFFSET MENS_7
	CALL PUTS 
	XOR AX,AX
	XOR BX,BX
	XOR CX,CX
	XOR DX,DX ;LIMPIAMOS LOS REGISTROS 
	MOV AL,3
	MOV BL,'A'
	MOV CL,'B'
	MOV DL,'C'
	CALL TorresDeHanoi
	
	MOV AH,04CH	;FINALIZACION DEL PROGRAMA 
	MOV AL,0
	INT 21H
	ENDP
	
	TorresDeHanoi PROC
	PUSH AX
	PUSH BX
	PUSH DX
	PUSH CX 	;SALVAMOS REGISTROS 
	
	CMP AL,1	;HACEMOS EL CASO BASE EL CUAL SERIA SOLO TENER 1 DISCO 
	JNE @@HANOI_E
	PUSH DX 	;HACEMOS OTRA COPIA DEL DATO DE DX 
	MOV DX,OFFSET mENS_4 	;MENSAJE DE DISCO
	CALL PUTS 
	ADD AL,30H	;PARA HACER VALOR IMPRIMIBLE DEL NUMERO
	CALL PUTCHAR 
	MOV DX,OFFSET mENS_5	;CARACTER DE :
	CALL PUTS 
	MOV AL,BL		
	CALL PUTCHAR 
	MOV DX,OFFSET mENS_6	;MENSAJE DE CARACTER ->
	CALL PUTS 
	POP DX
	MOV DH,0
	MOV AL,DL
	CALL PUTCHAR 
	JMP @@FIN 
	;PARTE RECURSIVA SALIMOS DEL CASO BASE 
	@@HANOI_E:
	XCHG CL,DL  ;INTERCXAMBIAMOS VALORES
	PUSH DX		;GUARDAMOS EL VALOR EN LA PILA 
	MOV DX,OFFSET mENS_4
	CALL PUTS 	;IMPRIMIRMOS EL MENSAGE DE DISCO
	ADD AL,30H	;AJUSTAMOS EL VALOR NUMERICO 
	CALL PUTCHAR ;IMPRIMIMOS EL NUMERO 
	MOV DX,OFFSET mENS_5 ;IMPRIMIMOS EL CARACTER :
	CALL PUTS 
	PUSH AX		;SALVAMOS EL VALOR DE AL  
	MOV AL,BL 	;MOVEMOS EL CARACTER DEL ORIGEN QUE ESTA EN BL
	CALL PUTCHAR  
	MOV DX,OFFSET mENS_6 ;IMPRIMIMOS EL ->
	CALL PUTS 
	POP AX 		;RECUPERAMOS AX 
	MOV AH,0	;PARA NO TENER BASURA EN LA PARTE ALTA 
	POP DX 		;RECUPERAMOS EL VALOR DE DX 
	MOV DH,0	;PARA NO TENER BASURA EN LA PARTE ALTA
	PUSH AX 	;GUARDAMOS OTRA VEZ EL VALOR DEL N-1
	MOV AL,DL 	;MOVEMOS EL VALOR DEL DESTINO 
	CALL PUTCHAR
	POP AX 
	MOV AH,0	;PARA NO TENER BASURA EN LA PARTE ALTA 
	SUB AL,30H	;RESTAMOS LA DIFERENCIA DEL AJUSTE 
	DEC AL 		;DECREMENTAMOS AL OTRA VEZ 
	XCHG CL,DL 
	XCHG BL,CL 
	CALL TorresDeHanoi
	
	@@FIN:
	POP CX		;RECUPERAMOS LOS REGISTROS 
	POP DX
	POP BX
	POP AX 
	RET 
	ENDP 
	printBinRec PROC
	;DESPLIEGA EN PANTALLA EL VALOR DE AL EN FORMATO BINARIO
	
	MOV AH,AL 
	CMP AH,0	;CASO BASE DONDE EL REG BL SEA 0 
	JNE @@NXT
	MOV AL,'0'
	CALL PUTCHAR;PARA PODER IMPRIMIR EL ULTIMO CERO 
	JMP @@FIN
@@NXT:
	MOV AL,0	;INICIALIZAMOS AL EN 0 
	SHL AH,1 	;DEZPLAZAMOS UN BIT A LA IZQUIERDA 
	ADC AL,30H	;SUMAMOS CON ACARREO EN EL REGISTRO AL
	CALL PUTCHAR 
	MOV AL,AH 	
	CALL printBinRec
	@@FIN:
	RET 
	ENDP 
	
	MCD PROC 
	;PROGRAMA RECURSIVO DEL MCD EL CUAL RECIBE DOS NUMEROS 
	;EN AL Y BL Y RETORNA EN AL SU MAXIMO COMUN DIVISOR POR EL 
	;ALGORITMO DE EUCLIDES.
	DIV BL 		;AL=AX/BL
	MOV AL,BL	;MOVEMOS EL VALOR DE BL COMO DIVIDENDO 
	CMP AH,0	;CASO BASE DONDE EL RESIDUO SEA 0 
	JE @@FIN 
	MOV BL,AH 	;MOVEMOS EL VALOR DEL RESICUO A BL PARA HACER DIVICIONES CON EL
	MOV AH,0
	CALL MCD 	;LLAMAMOS EL PROC PARA HACER LA RECURCION 
	@@FIN:
	MOV AL,BL 	;SI EL RESIDUO ES CERO ENTONCES MANDAMOS EL RECIDUO ANTERIOR 
	ADD AX,30H	;SE AJUSTA A SU VALOR VERDADERO
				
	RET 
	ENDP
	
END